# 컨테이너 기술 기초

## 컨테이너란?

**컨테이너(Container)** 는 애플리케이션과 그 실행에 필요한 모든 것(코드, 런타임, 라이브러리, 설정)을 하나의 패키지로 묶어서 격리된 환경에서 실행하는 기술입니다.

### 실생활 비유로 이해하기

```
현실 세계의 컨테이너 (화물 컨테이너):
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

┌─────────────────────┐
│   표준화된 박스      │
│                     │
│  무엇을 담든:       │
│  - 전자제품         │
│  - 의류             │
│  - 식품             │
│                     │
│  어떤 수송수단이든: │
│  - 배               │
│  - 트럭             │
│  - 기차             │
│                     │
│  → 동일하게 운송    │
└─────────────────────┘

소프트웨어 컨테이너:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

┌─────────────────────┐
│   표준화된 패키지    │
│                     │
│  무엇을 담든:       │
│  - Node.js 앱       │
│  - Python 앱        │
│  - Java 앱          │
│                     │
│  어디서 실행하든:   │
│  - 내 노트북        │
│  - 테스트 서버      │
│  - AWS 클라우드     │
│                     │
│  → 동일하게 실행    │
└─────────────────────┘
```

---

## 왜 컨테이너가 필요한가?

### 문제 상황: "내 컴퓨터에선 되는데요?"

```
개발자 A의 컴퓨터:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
- macOS
- Python 3.9
- pip로 설치한 라이브러리들
- 특정 환경 변수 설정
→ "완벽하게 동작해요!" ✓

테스터 B의 컴퓨터:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
- Windows
- Python 3.10
- 다른 버전의 라이브러리
- 환경 변수 없음
→ "실행이 안 돼요..." ✗

운영 서버:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
- Ubuntu Linux
- Python 3.8
- 일부 라이브러리만 설치됨
- 다른 앱과 라이브러리 충돌
→ "서버가 다운됐어요!" ✗✗✗
```

### 컨테이너 사용 시

```
모든 환경에서 동일한 컨테이너:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

┌──────────────────────────────┐
│      내 Python 앱 컨테이너    │
├──────────────────────────────┤
│ - Python 3.9                 │
│ - 필요한 모든 라이브러리      │
│ - 환경 변수                  │
│ - 설정 파일                  │
│ - 내 애플리케이션 코드        │
└──────────────────────────────┘
         ↓         ↓         ↓
    개발 PC    테스트 서버  운영 서버
      ✓          ✓          ✓
   동일하게 실행됨!
```

---

## 컨테이너 vs 가상 머신 (VM)

### 가상 머신 (Virtual Machine)

```
가상 머신 구조:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

┌─────────────────────────────────────┐
│         물리적 서버 (호스트)         │
│                                     │
│  ┌──────────┐  ┌──────────┐       │
│  │  VM 1    │  │  VM 2    │       │
│  │          │  │          │       │
│  │  앱 A    │  │  앱 B    │       │
│  │  앱 C    │  │  앱 D    │       │
│  ├──────────┤  ├──────────┤       │
│  │ Ubuntu   │  │ CentOS   │ ← 각 VM마다
│  │  OS      │  │  OS      │   전체 OS
│  │  전체    │  │  전체    │   복사본
│  └──────────┘  └──────────┘       │
│                                     │
│  ┌─────────────────────────────┐   │
│  │      Hypervisor             │   │
│  │    (VMware, VirtualBox)     │   │
│  └─────────────────────────────┘   │
│                                     │
│  ┌─────────────────────────────┐   │
│  │      Host OS (Linux)        │   │
│  └─────────────────────────────┘   │
│                                     │
│  ┌─────────────────────────────┐   │
│  │        Hardware             │   │
│  │    (CPU, RAM, Disk)         │   │
│  └─────────────────────────────┘   │
└─────────────────────────────────────┘

특징:
- 각 VM이 완전한 OS 포함
- 크기: 수 GB
- 부팅 시간: 분 단위
- 메모리: GB 단위
- 격리: 매우 강력 (하드웨어 레벨)
```

### 컨테이너

```
컨테이너 구조:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

┌─────────────────────────────────────┐
│         물리적 서버 (호스트)         │
│                                     │
│  ┌──────────┐  ┌──────────┐       │
│  │Container1│  │Container2│       │
│  │          │  │          │       │
│  │  앱 A    │  │  앱 B    │       │
│  │  앱 C    │  │  앱 D    │       │
│  │  라이브  │  │  라이브  │       │
│  │  러리    │  │  러리    │       │
│  └──────────┘  └──────────┘       │
│                                     │
│  ┌─────────────────────────────┐   │
│  │    Container Runtime        │   │
│  │     (Docker, containerd)    │   │
│  └─────────────────────────────┘   │
│                                     │
│  ┌─────────────────────────────┐   │
│  │      Host OS (Linux)        │ ← OS 하나만
│  └─────────────────────────────┘   공유 사용
│                                     │
│  ┌─────────────────────────────┐   │
│  │        Hardware             │   │
│  │    (CPU, RAM, Disk)         │   │
│  └─────────────────────────────┘   │
└─────────────────────────────────────┘

특징:
- OS 커널 공유
- 크기: 수십~수백 MB
- 시작 시간: 초 단위
- 메모리: MB 단위
- 격리: 충분함 (프로세스 레벨)
```

### 비교표

```
┌──────────────┬─────────────────┬─────────────────┐
│   항목       │   가상 머신      │   컨테이너       │
├──────────────┼─────────────────┼─────────────────┤
│ 크기         │ 수 GB           │ 수십~수백 MB    │
│ 시작 시간    │ 분 단위         │ 초 단위         │
│ 성능         │ 오버헤드 있음   │ 거의 네이티브   │
│ 격리         │ 완전 격리       │ 프로세스 격리   │
│ OS          │ 각각 독립       │ 커널 공유       │
│ 리소스 사용  │ 많음            │ 적음            │
│ 포터빌리티   │ 낮음            │ 높음            │
└──────────────┴─────────────────┴─────────────────┘
```

---

## 컨테이너는 어떻게 작동하는가?

### 1. 프로세스 격리

일반적으로 생각하면 컨테이너는 "가벼운 가상 머신"처럼 보이지만, 실제로는 **그냥 특별한 프로세스**입니다.

```
일반 프로세스:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

$ python app.py

→ OS에서 실행되는 하나의 프로세스
→ 다른 프로세스들과 리소스 공유
→ 파일 시스템 공유
→ 네트워크 공유
→ 서로 영향을 줄 수 있음

컨테이너 프로세스:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

$ docker run python-app

→ OS에서 실행되는 특별한 프로세스
→ 자신만의 격리된 환경
→ 자신만의 파일 시스템 (처럼 보임)
→ 자신만의 네트워크 (처럼 보임)
→ 다른 프로세스로부터 격리됨

핵심: 컨테이너 = 격리된 프로세스
```

### 2. 실제 동작 예제

```bash
# 호스트 시스템에서 프로세스 목록 보기
$ ps aux | grep nginx
nobody   1234  0.0  0.1  nginx: master process

# 컨테이너 안에서 프로세스 목록 보기
$ docker exec mycontainer ps aux
USER  PID  CMD
root   1   nginx: master process
root   2   nginx: worker process

→ 컨테이너 안에서는 PID 1로 보임
→ 호스트에서는 PID 1234로 보임
→ 같은 프로세스를 다르게 보는 것!
```

---

## 리눅스 컨테이너 기술의 핵심

컨테이너는 리눅스 커널의 두 가지 핵심 기능을 사용합니다:

### 1. Namespaces (네임스페이스) - 격리

**Namespace**는 프로세스가 보는 "세상"을 분리합니다.

```
비유: 아파트 건물
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

┌─────────────────────────────────┐
│         아파트 건물              │
│                                 │
│  ┌──────┐  ┌──────┐            │
│  │101호 │  │102호 │            │
│  │      │  │      │            │
│  │ 가족A│  │ 가족B│            │
│  └──────┘  └──────┘            │
│                                 │
│  - 각 집은 독립된 공간          │
│  - 벽으로 분리됨                │
│  - 서로의 집 내부를 볼 수 없음   │
│  - 하지만 같은 건물, 같은 땅     │
└─────────────────────────────────┘

Namespace = 가상의 벽
같은 커널을 사용하지만 서로 격리됨
```

#### Namespace 종류

**PID Namespace (Process ID)**

```
호스트 시스템:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
PID 1    → systemd
PID 100  → sshd
PID 200  → nginx (호스트)
PID 500  → [컨테이너 A의 nginx]
PID 800  → [컨테이너 B의 nginx]

컨테이너 A 안에서:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
PID 1    → nginx (자신이 첫 번째 프로세스라고 생각)
PID 2    → nginx worker

컨테이너 B 안에서:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
PID 1    → nginx (자신이 첫 번째 프로세스라고 생각)
PID 2    → nginx worker

→ 각 컨테이너는 자신만의 PID 공간을 가짐
→ 서로의 프로세스를 볼 수 없음
```

**Network Namespace**

```
┌─────────────────────────────────────┐
│           호스트 시스템              │
│                                     │
│  네트워크: eth0 (192.168.1.100)     │
│                                     │
│  ┌──────────────┐  ┌──────────────┐│
│  │ 컨테이너 A   │  │ 컨테이너 B   ││
│  │              │  │              ││
│  │ eth0         │  │ eth0         ││
│  │ 172.17.0.2   │  │ 172.17.0.3   ││
│  └──────────────┘  └──────────────┘│
└─────────────────────────────────────┘

각 컨테이너는:
- 자신만의 네트워크 인터페이스
- 자신만의 IP 주소
- 자신만의 라우팅 테이블
- 자신만의 포트 범위

→ 컨테이너 A와 B 모두 80 포트 사용 가능!
→ 호스트에서는 다른 포트로 매핑
```

**Mount Namespace (파일 시스템)**

```
호스트 파일 시스템:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
/
├── bin/
├── usr/
├── home/
└── var/

컨테이너 A 파일 시스템:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
/
├── bin/       ← 컨테이너 전용
├── usr/       ← 컨테이너 전용
├── app/       ← 애플리케이션 코드
└── data/

컨테이너 B 파일 시스템:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
/
├── bin/       ← 별도의 컨테이너 전용
├── usr/       ← 별도의 컨테이너 전용
├── app/       ← 다른 애플리케이션
└── data/

→ 각 컨테이너는 자신만의 루트 파일 시스템
→ 다른 컨테이너의 파일을 볼 수 없음
```

**User Namespace**

```
보안 강화:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

컨테이너 내부:
UID 0 (root) → 모든 권한이 있는 것처럼 보임

호스트 시스템:
UID 1000 (일반 사용자) → 실제로는 제한된 권한

→ 컨테이너 안에서 root로 실행되어도
→ 호스트에서는 일반 사용자 권한만 가짐
→ 컨테이너가 탈출해도 피해 최소화
```

**기타 Namespace**

```
IPC Namespace
→ Inter-Process Communication
→ 공유 메모리, 세마포어 등 격리

UTS Namespace
→ Hostname 격리
→ 각 컨테이너가 자신만의 호스트명 가짐
```

### 2. cgroups (Control Groups) - 리소스 제한

**cgroups**는 프로세스가 사용할 수 있는 리소스를 제한합니다.

```
비유: 식당 테이블 예약
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

┌─────────────────────────────────┐
│          식당 (서버)             │
│                                 │
│  전체 테이블: 10개               │
│                                 │
│  테이블 1-3: 그룹 A (3개)       │
│  테이블 4-6: 그룹 B (3개)       │
│  테이블 7-10: 공용 (4개)        │
│                                 │
│  → 그룹 A는 최대 3개만 사용     │
│  → 아무리 손님이 많아도 3개 제한 │
└─────────────────────────────────┘

cgroups = 리소스 예약/제한
각 컨테이너가 사용할 수 있는 리소스 제한
```

#### cgroups로 제어 가능한 리소스

**CPU**

```bash
# 컨테이너 A: CPU 2 core 제한
docker run --cpus="2.0" container-a

# 컨테이너 B: CPU 0.5 core 제한
docker run --cpus="0.5" container-b

# CPU 사용률 가중치 설정
docker run --cpu-shares=512 container-c
```

```
실제 동작:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

┌─────────────────────────────────┐
│      물리적 CPU (4 cores)        │
├─────────────────────────────────┤
│  Core 1-2: 컨테이너 A           │
│  Core 3: 컨테이너 B (절반)      │
│  Core 4: 다른 프로세스           │
└─────────────────────────────────┘

→ 컨테이너 A가 아무리 바쁘어도 2 core 넘지 못함
→ 다른 컨테이너 성능에 영향 주지 않음
```

**Memory**

```bash
# 메모리 512MB 제한
docker run --memory="512m" container-a

# 메모리 + Swap 1GB 제한
docker run --memory="512m" --memory-swap="1g" container-b

# OOM (Out of Memory) 발생 시 컨테이너 종료
docker run --memory="512m" --oom-kill-disable=false container-c
```

```
메모리 사용:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

컨테이너 메모리 사용량 증가...
100MB → 200MB → 300MB → 400MB → 512MB

512MB 도달!
→ 더 이상 메모리 할당 불가
→ OOM Killer 작동
→ 컨테이너 프로세스 종료

→ 호스트 시스템은 안전하게 유지됨
```

**Disk I/O**

```bash
# 디스크 읽기/쓰기 속도 제한
docker run \
  --device-read-bps /dev/sda:1mb \
  --device-write-bps /dev/sda:1mb \
  container-a

# I/O 가중치 설정
docker run --blkio-weight=500 container-b
```

**Network**

```bash
# 네트워크 대역폭 제한 (tc 사용)
# 컨테이너가 최대 1Mbps만 사용하도록
tc qdisc add dev eth0 root tbf rate 1mbit burst 32kbit
```

---

## 컨테이너 격리 시연

### 실험 1: PID Namespace

```bash
# 호스트에서 프로세스 확인
$ ps aux
USER       PID  COMMAND
root         1  /sbin/init
root       100  /usr/sbin/sshd
root       200  nginx
...

# 컨테이너 실행
$ docker run -it ubuntu bash

# 컨테이너 안에서 프로세스 확인
container$ ps aux
USER       PID  COMMAND
root         1  bash          ← 자신이 PID 1!
root        10  ps

# 컨테이너는 자신이 유일한 프로세스라고 생각함
```

### 실험 2: Mount Namespace

```bash
# 호스트에서 파일 생성
$ echo "secret" > /tmp/secret.txt

# 컨테이너 실행
$ docker run -it ubuntu bash

# 컨테이너 안에서 파일 찾기
container$ ls /tmp/
# → secret.txt가 보이지 않음!
# 컨테이너는 자신만의 파일 시스템을 가짐
```

### 실험 3: Network Namespace

```bash
# 호스트의 네트워크 확인
$ ip addr
eth0: 192.168.1.100

# 컨테이너 실행
$ docker run -it ubuntu bash

# 컨테이너의 네트워크 확인
container$ ip addr
eth0: 172.17.0.2    ← 다른 IP!

# 각 컨테이너는 자신만의 네트워크 스택을 가짐
```

---

## 컨테이너 이미지와 레이어

### Union File System

컨테이너는 **레이어(Layer)** 기반 파일 시스템을 사용합니다.

```
레이어 구조:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

읽기 전용 레이어들 (이미지):
┌──────────────────────────────┐
│ Layer 4: 내 앱 코드          │ 10 MB
├──────────────────────────────┤
│ Layer 3: npm install         │ 50 MB
├──────────────────────────────┤
│ Layer 2: Node.js 설치        │ 100 MB
├──────────────────────────────┤
│ Layer 1: Ubuntu 기본 시스템   │ 200 MB
└──────────────────────────────┘
           ↓
    Union File System
           ↓
┌──────────────────────────────┐
│ Container Layer (쓰기 가능)   │ 변경사항만
└──────────────────────────────┘

특징:
✓ 읽기 전용 레이어는 여러 컨테이너가 공유
✓ 쓰기는 Container Layer에만
✓ 레이어 캐싱으로 빠른 빌드
```

### Copy-on-Write (CoW)

```
파일 읽기:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

컨테이너가 /app/config.json 읽기
  ↓
레이어 4부터 아래로 검색
  ↓
레이어 3에서 발견!
  ↓
파일 내용 반환

파일 쓰기 (수정):
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

컨테이너가 /app/config.json 수정
  ↓
레이어 3의 파일을 Container Layer로 복사
  ↓
Container Layer에서 수정
  ↓
이후 읽기는 Container Layer에서

→ 원본 레이어는 변경되지 않음
→ 다른 컨테이너에 영향 없음
```

### 레이어 공유 예제

```
이미지 A (Node.js 앱):
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
Layer 4: 앱 A 코드 (5MB)
Layer 3: npm packages (40MB)
Layer 2: Node.js 18 (100MB)
Layer 1: Ubuntu (200MB)

이미지 B (다른 Node.js 앱):
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
Layer 4: 앱 B 코드 (8MB)
Layer 3: npm packages (45MB)
Layer 2: Node.js 18 (100MB)  ← 이미 있음! (공유)
Layer 1: Ubuntu (200MB)       ← 이미 있음! (공유)

디스크 사용량:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
이미지 A: 345MB
이미지 B: 398MB (예상)

실제: 345MB + 53MB = 398MB
→ 공통 레이어(300MB)는 한 번만 저장
```

---

## 컨테이너 생명주기

```
컨테이너 상태:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

    [Created]
        ↓
    docker start
        ↓
    [Running] ←─────┐
        │           │
        │      docker restart
        ↓           │
    docker stop     │
        ↓           │
    [Stopped] ──────┘
        ↓
    docker rm
        ↓
    [Deleted]

실행 중:
- 프로세스 실행 중
- 리소스 사용 중
- 네트워크 활성

중지:
- 프로세스 종료
- 리소스 반환
- 파일 시스템 유지
```

---

## 실제로 컨테이너 만들어보기

### 간단한 예제

```bash
# 1. 이미지 다운로드
docker pull ubuntu:latest

# 2. 컨테이너 생성 및 실행
docker run -it ubuntu bash

# 이제 컨테이너 안에 있습니다!
# 파일 시스템 확인
root@container:/# ls
bin  boot  dev  etc  home  lib  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var

# 프로세스 확인
root@container:/# ps aux
USER       PID  COMMAND
root         1  bash
root        10  ps

# 네트워크 확인
root@container:/# ip addr
eth0: 172.17.0.2

# 호스트 이름 확인
root@container:/# hostname
a3f8d9e2b1c4

# 파일 생성
root@container:/# echo "Hello from container" > /tmp/hello.txt

# 컨테이너 종료
root@container:/# exit
```

### 변경사항 확인

```bash
# 컨테이너 다시 시작
docker start <container-id>
docker exec -it <container-id> bash

# 파일이 남아있음
root@container:/# cat /tmp/hello.txt
Hello from container

# 컨테이너 삭제
docker stop <container-id>
docker rm <container-id>

# 새 컨테이너 시작
docker run -it ubuntu bash

# 파일이 없음 (새 컨테이너)
root@container:/# cat /tmp/hello.txt
No such file or directory
```

---

## 컨테이너 격리의 한계

### 커널 공유

```
한계:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

✗ 다른 커널 버전 사용 불가
  → 호스트가 Linux 5.10이면 컨테이너도 5.10

✗ 다른 OS 커널 사용 불가
  → Linux 호스트에서 Windows 컨테이너 안 됨
  → (Windows 컨테이너는 Windows 호스트 필요)

✗ 커널 버그/취약점 공유
  → 호스트 커널의 보안 문제가 컨테이너에도 영향

✗ VM보다 격리 수준 낮음
  → 특정 상황에서 탈출 가능성
  → (하지만 실무에서는 충분히 안전)
```

### 보안 고려사항

```
보안 강화 방법:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

✓ 루트 권한으로 실행하지 않기
  → USER 지시어 사용

✓ 읽기 전용 파일 시스템
  → docker run --read-only

✓ Capability 제한
  → --cap-drop=ALL

✓ Seccomp 프로파일
  → 시스템 콜 제한

✓ AppArmor/SELinux
  → 강제 접근 제어
```

---

## 정리

### 핵심 개념

```
컨테이너 = 격리된 프로세스
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

격리 메커니즘:
┌─────────────────────────────────┐
│        Namespaces               │
│     (무엇을 볼 수 있는가)         │
│                                 │
│  - PID: 프로세스 격리            │
│  - Network: 네트워크 격리        │
│  - Mount: 파일 시스템 격리       │
│  - User: 사용자 격리             │
│  - IPC: 프로세스 간 통신 격리    │
│  - UTS: 호스트명 격리            │
└─────────────────────────────────┘

리소스 제한:
┌─────────────────────────────────┐
│         cgroups                 │
│  (얼마나 사용할 수 있는가)        │
│                                 │
│  - CPU: 처리 능력 제한           │
│  - Memory: 메모리 제한           │
│  - Disk I/O: 디스크 속도 제한    │
│  - Network: 네트워크 대역폭 제한 │
└─────────────────────────────────┘

파일 시스템:
┌─────────────────────────────────┐
│    Union File System            │
│    (레이어 기반 파일 시스템)     │
│                                 │
│  - 읽기 전용 레이어 공유         │
│  - Copy-on-Write                │
│  - 효율적인 저장 공간 사용       │
└─────────────────────────────────┘
```

### 컨테이너 vs VM

```
사용 시나리오:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

컨테이너 사용:
✓ 마이크로서비스 아키텍처
✓ 빠른 배포 필요
✓ 같은 OS에서 여러 앱 실행
✓ CI/CD 파이프라인
✓ 개발 환경 통일

VM 사용:
✓ 다른 OS 필요
✓ 완전한 격리 필요
✓ 레거시 애플리케이션
✓ 다른 커널 버전 필요
```

---

## 다음 단계

컨테이너 기본 개념을 이해했다면:

1. [Docker 상세 가이드](docker.md)
2. [Docker Compose 실습](docker-compose-guide.md)
3. [Kubernetes 기초](kubernetes-basics.md)

---

## 추가 학습 자료

**Linux Namespace 실습:**
```bash
# PID namespace 직접 만들어보기
unshare --pid --fork --mount-proc bash
ps aux  # 새로운 PID namespace!

# Network namespace 만들기
ip netns add myns
ip netns exec myns ip addr
```

**참고 자료:**
- [Linux Namespaces - man page](https://man7.org/linux/man-pages/man7/namespaces.7.html)
- [Control Groups (cgroups)](https://www.kernel.org/doc/Documentation/cgroup-v2.txt)
- [Container Internals - Red Hat](https://www.redhat.com/en/blog/understanding-container-internals)

---

*Last updated: 2026-01-09*
