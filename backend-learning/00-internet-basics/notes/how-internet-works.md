# 인터넷은 어떻게 작동하는가?

## 개요

인터넷은 전 세계의 수십억 개의 컴퓨터와 디바이스를 연결하는 거대한 네트워크입니다. 백엔드 개발자로서 인터넷의 작동 원리를 이해하는 것은 효율적이고 안정적인 서버 애플리케이션을 구축하는 데 필수적입니다.

---

## 핵심 개념

### 1. 클라이언트-서버 모델

```
┌─────────────┐                    ┌─────────────┐
│   클라이언트  │ ─── 요청(Request) ──→ │    서버     │
│  (Browser)  │                    │   (Server)  │
│             │ ←── 응답(Response) ── │             │
└─────────────┘                    └─────────────┘
```

- **클라이언트**: 서비스를 요청하는 쪽 (웹 브라우저, 모바일 앱 등)
- **서버**: 요청을 처리하고 응답을 제공하는 쪽 (백엔드 애플리케이션)

### 2. 인터넷 vs 웹

많은 사람들이 혼동하지만 다른 개념입니다:

| 구분   | 인터넷 (Internet)          | 웹 (World Wide Web)    |
| ---- | ----------------------- | --------------------- |
| 정의   | 전 세계 컴퓨터를 연결하는 네트워크 인프라 | 인터넷 위에서 동작하는 서비스 중 하나 |
| 역할   | 물리적/논리적 연결 제공           | HTTP를 통한 정보 공유 시스템    |
| 프로토콜 | TCP/IP, UDP 등           | HTTP/HTTPS            |

---

## 데이터가 전송되는 과정

### 1. 패킷 (Packets)

인터넷에서 데이터는 작은 조각인 **패킷**으로 나뉘어 전송됩니다.

```
원본 데이터: "Hello, World!" (큰 파일이라고 가정)

┌──────────┐  ┌──────────┐  ┌──────────┐
│ Packet 1 │  │ Packet 2 │  │ Packet 3 │
│  "Hello" │  │  ", Wor" │  │   "ld!"  │
└──────────┘  └──────────┘  └──────────┘
     ↓              ↓              ↓
         (각기 다른 경로로 전송)
     ↓              ↓              ↓
┌─────────────────────────────────────┐
│  목적지에서 재조립: "Hello, World!"  │
└─────────────────────────────────────┘
```

**패킷의 장점**:
- 네트워크 효율성 증가
- 오류 발생 시 일부만 재전송
- 다중 경로 사용 가능

### 2. 라우팅 (Routing)

패킷이 출발지에서 목적지까지 가는 경로를 찾는 과정입니다.

```
클라이언트 (한국)
    ↓
로컬 라우터
    ↓
ISP 라우터 (KT, SK 등)
    ↓
국제 백본 네트워크
    ↓
목적지 ISP
    ↓
목적지 서버 (미국)
```

**라우터의 역할**:
- 최적 경로 결정
- 패킷 전달
- 네트워크 트래픽 관리

---

## TCP/IP 프로토콜 스택

인터넷은 **TCP/IP** 모델을 기반으로 동작합니다.

```
┌──────────────────────────────────────┐
│   Application Layer (응용 계층)       │  HTTP, HTTPS, FTP, SMTP
├──────────────────────────────────────┤
│   Transport Layer (전송 계층)         │  TCP, UDP
├──────────────────────────────────────┤
│   Internet Layer (인터넷 계층)        │  IP (IPv4, IPv6)
├──────────────────────────────────────┤
│   Network Access Layer (네트워크 계층) │  Ethernet, Wi-Fi
└──────────────────────────────────────┘
```

### 각 계층의 역할

#### 1. Application Layer (응용 계층)
- 사용자 애플리케이션과 직접 상호작용
- 프로토콜: HTTP, HTTPS, FTP, SMTP, DNS
- 백엔드 개발자가 주로 작업하는 계층

#### 2. Transport Layer (전송 계층)
- 데이터 전송의 신뢰성 보장
- **TCP**: 연결 지향, 신뢰성 보장 (웹, 이메일)
- **UDP**: 비연결, 빠른 전송 (스트리밍, 게임)

**TCP vs UDP 핵심 차이**:

### TCP (Transmission Control Protocol) - 연결 지향

```
┌─────────┐                           ┌─────────┐
│ Client  │ ── SYN ────────────────→  │ Server  │
│         │ ←─ SYN-ACK ──────────────  │         │
│         │ ── ACK ────────────────→  │         │
└─────────┘                           └─────────┘
     │                                     │
     ├─────── 연결이 유지됨 ────────────────┤
     │                                     │
     ├─ Data 1 ────────────────────────→  │
     │ ←─ ACK ──────────────────────────  │
     ├─ Data 2 ────────────────────────→  │
     │ ←─ ACK ──────────────────────────  │
     ├─ Data 3 ────────────────────────→  │
     │ ←─ ACK ──────────────────────────  │
     │                                     │
     ├─ FIN (연결 종료) ───────────────→  │
     │ ←─ ACK ──────────────────────────  │
     │ ←─ FIN ──────────────────────────  │
     ├─ ACK ────────────────────────────→ │
└─────────┘                           └─────────┘

특징:
✓ 연결 설정 필수 (3-way handshake)
✓ 연결 유지 - 세션이 끊어지기 전까진 계속 연결됨
✓ 데이터 순서 보장 (패킷에 번호 부여)
✓ 오류 검출 및 재전송 (ACK 확인)
✓ 흐름 제어 (수신자 버퍼 고려)
✓ 혼잡 제어 (네트워크 상황 고려)
✗ 오버헤드가 큼 (연결 설정, ACK 등)
✗ 속도가 상대적으로 느림

→ 사용 예: HTTP, HTTPS, SSH, 이메일, 파일 전송
```

### UDP (User Datagram Protocol) - 비연결 지향

```
┌─────────┐                           ┌─────────┐
│ Client  │                           │ Server  │
│         │                           │         │
│         │ ── Packet 1 ─────────────→│         │
│         │ ── Packet 2 ─────────────→│         │
│         │ ── Packet 3 ─────────────→│         │
│         │                           │         │
│         │  (연결 설정 없음)          │         │
│         │  (ACK 없음)                │         │
│         │  (그냥 쏘고 끝)            │         │
└─────────┘                           └─────────┘

특징:
✓ 연결 설정 없음 - 그냥 목적지로 던지고 끝
✓ 빠른 전송 (오버헤드 최소)
✓ 실시간 통신에 적합
✗ 신뢰성 보장 안 됨 (패킷 손실 가능)
✗ 순서 보장 안 됨
✗ 흐름 제어 없음
✗ 혼잡 제어 없음

→ 사용 예: 동영상 스트리밍, DNS, 온라인 게임, VoIP
```

### 왜 UDP가 빠른가?

```
TCP:
1. 연결 설정 (3-way handshake)     ← 시간 소요
2. 데이터 전송
3. ACK 대기                        ← 시간 소요
4. 패킷 순서 확인                  ← 오버헤드
5. 연결 종료 (4-way handshake)     ← 시간 소요

UDP:
1. 데이터 전송 (끝!)                ← 빠름!
   - 연결 설정 없음
   - ACK 대기 없음
   - 순서 확인 없음
```

### 실무 예제로 이해하기

**TCP 예시 - 전화 통화**
```
1. 전화를 걸음 (SYN)
2. 상대방이 받음 (SYN-ACK)
3. "여보세요?" (ACK)
4. ─── 통화 시작 (연결 유지) ───
5. 대화 주고받기 (데이터 전송)
6. 상대방이 내용을 확인 (ACK)
7. ─── 통화 종료 ───
8. "끊을게요" (FIN)

→ 확실하게 전달되지만, 과정이 복잡함
```

**UDP 예시 - 우편함에 편지 넣기**
```
1. 편지를 우편함에 넣음 (끝!)
   - 상대방이 받았는지 확인 안 함
   - 순서대로 도착하는지 몰라
   - 편지가 분실될 수도 있음

→ 빠르지만, 신뢰성이 낮음
```

### 언제 무엇을 사용할까?

**TCP 사용 (신뢰성 중요)**
```
✓ 웹사이트 (HTTP/HTTPS)
  - 모든 데이터가 정확히 전달되어야 함

✓ 파일 다운로드 (FTP)
  - 파일이 손상되면 안 됨

✓ 이메일 (SMTP)
  - 메일이 누락되면 안 됨

✓ 데이터베이스 통신
  - 데이터 정확성이 매우 중요
```

**UDP 사용 (속도 중요)**
```
✓ 동영상 스트리밍 (YouTube, Netflix)
  - 일부 프레임이 손실되어도 괜찮음
  - 실시간성이 더 중요

✓ 온라인 게임
  - 캐릭터 위치가 약간 어긋나도 괜찮음
  - 지연(latency)이 없는 게 중요

✓ DNS 조회
  - 빠른 응답이 중요
  - 실패하면 다시 요청하면 됨

✓ VoIP (음성 통화)
  - 약간의 끊김은 괜찮음
  - 실시간 통화가 중요
```

#### 3. Internet Layer (인터넷 계층)
- IP 주소를 사용한 라우팅
- 패킷을 목적지까지 전달
- IPv4 (예: 192.168.0.1), IPv6 (예: 2001:0db8:85a3::8a2e:0370:7334)

#### 4. Network Access Layer (네트워크 접근 계층)
- 물리적 네트워크 하드웨어
- Ethernet, Wi-Fi 등

---

## IP 주소와 포트

### IP 주소 (IP Address)

인터넷상의 각 디바이스를 식별하는 고유 주소입니다.

```
IPv4: 192.168.1.1 (32비트, 약 43억 개)
IPv6: 2001:0db8:85a3:0000:0000:8a2e:0370:7334 (128비트)
```

**IP 주소 종류**:
- **공인 IP**: 인터넷에서 접근 가능한 주소
- **사설 IP**: 내부 네트워크에서만 사용 (192.168.x.x, 10.x.x.x)

### 포트 (Port)

하나의 서버에서 여러 서비스를 구분하는 번호입니다.

```
192.168.1.1:80    ← 웹 서버 (HTTP)
192.168.1.1:443   ← 웹 서버 (HTTPS)
192.168.1.1:3306  ← MySQL 데이터베이스
192.168.1.1:5432  ← PostgreSQL 데이터베이스
```

**주요 포트 번호**:
- 80: HTTP
- 443: HTTPS
- 22: SSH
- 21: FTP
- 3000: Node.js 개발 서버 (관례)
- 8080: 대체 HTTP 포트

---

## 웹 페이지 로딩 과정 (전체 흐름)

사용자가 브라우저에 `https://example.com`을 입력했을 때:

```
1. DNS 조회
   ┌──────────────────────────────────────────┐
   │ example.com → 93.184.216.34로 변환       │
   └──────────────────────────────────────────┘

2. TCP 연결 수립 (3-way handshake)
   ┌──────────────┐                ┌──────────────┐
   │ 클라이언트    │ ── SYN ──→     │    서버      │
   │              │ ←─ SYN-ACK ──  │              │
   │              │ ── ACK ──→     │              │
   └──────────────┘                └──────────────┘

3. TLS 핸드셰이크 (HTTPS인 경우)
   - 암호화 키 교환
   - 서버 인증서 검증

4. HTTP 요청 전송
   ┌──────────────────────────────────────────┐
   │ GET / HTTP/1.1                           │
   │ Host: example.com                        │
   │ User-Agent: Mozilla/5.0...               │
   └──────────────────────────────────────────┘

5. 서버 응답
   ┌──────────────────────────────────────────┐
   │ HTTP/1.1 200 OK                          │
   │ Content-Type: text/html                  │
   │                                          │
   │ <html>...</html>                         │
   └──────────────────────────────────────────┘

6. 브라우저 렌더링
   - HTML 파싱
   - CSS, JavaScript 로드
   - 화면에 표시
```

---

## ISP (Internet Service Provider)

인터넷 서비스 제공자는 사용자와 인터넷을 연결하는 회사입니다.

**한국의 주요 ISP**:
- KT
- SK 브로드밴드
- LG U+

**ISP의 역할**:
- 인터넷 연결 제공
- IP 주소 할당
- 라우팅 및 트래픽 관리
- DNS 서버 운영

---

## 네트워크 도구로 이해하기

### 1. `ping` - 서버 연결 확인

```bash
$ ping google.com
PING google.com (142.250.207.46): 56 data bytes
64 bytes from 142.250.207.46: icmp_seq=0 ttl=115 time=34.123 ms
64 bytes from 142.250.207.46: icmp_seq=1 ttl=115 time=33.891 ms
```

### 2. `traceroute` - 경로 추적

```bash
$ traceroute google.com
 1  192.168.0.1 (1.234 ms)        # 로컬 라우터
 2  10.1.1.1 (5.678 ms)           # ISP 라우터
 3  172.16.0.1 (12.345 ms)        # 백본 네트워크
...
12  142.250.207.46 (34.567 ms)   # Google 서버
```

### 3. `netstat` - 네트워크 연결 확인

```bash
$ netstat -an | grep LISTEN
tcp4  0  0  *.80        *.*  LISTEN   # HTTP 서버
tcp4  0  0  *.443       *.*  LISTEN   # HTTPS 서버
tcp4  0  0  *.3000      *.*  LISTEN   # 개발 서버
```

---

## 백엔드 개발자가 알아야 할 핵심

### 1. 요청-응답 사이클 이해
- 클라이언트가 요청을 보내는 방식
- 서버가 응답을 생성하는 과정
- 네트워크 지연(latency) 고려

### 2. 프로토콜 선택
- TCP: 신뢰성이 중요한 경우 (REST API, GraphQL)
- UDP: 실시간 통신 (WebRTC, 게임 서버)
- WebSocket: 양방향 실시간 통신

### 3. IP와 포트 관리
- 서버 바인딩 (`0.0.0.0:3000`)
- 방화벽 설정
- 포트 충돌 방지

### 4. 보안 고려사항
- HTTPS 사용 (TLS/SSL)
- DDoS 공격 대비
- 방화벽 규칙 설정

---

## 실무 예제

### Node.js 서버 예제

```javascript
const http = require('http');

// 서버 생성
const server = http.createServer((req, res) => {
  console.log(`요청 받음: ${req.method} ${req.url}`);
  console.log(`클라이언트 IP: ${req.socket.remoteAddress}`);

  // 응답 생성
  res.writeHead(200, { 'Content-Type': 'text/html; charset=utf-8' });
  res.end('<h1>안녕하세요, 인터넷!</h1>');
});

// 포트 3000에서 수신 대기
server.listen(3000, '0.0.0.0', () => {
  console.log('서버가 http://localhost:3000 에서 실행 중입니다');
});
```

### Python 서버 예제

```python
from http.server import HTTPServer, BaseHTTPRequestHandler

class SimpleHandler(BaseHTTPRequestHandler):
    def do_GET(self):
        print(f"요청 받음: {self.path}")
        print(f"클라이언트 IP: {self.client_address}")

        self.send_response(200)
        self.send_header('Content-Type', 'text/html; charset=utf-8')
        self.end_headers()
        self.wfile.write('<h1>안녕하세요, 인터넷!</h1>'.encode())

server = HTTPServer(('0.0.0.0', 3000), SimpleHandler)
print('서버가 http://localhost:3000 에서 실행 중입니다')
server.serve_forever()
```

---

## 추가 학습 자료

- [MDN - 인터넷의 작동 원리](https://developer.mozilla.org/ko/docs/Learn/Common_questions/How_does_the_Internet_work)
- [Khan Academy - 인터넷 101](https://www.khanacademy.org/computing/code-org/computers-and-the-internet)
- [How HTTPS Works (Comic)](https://howhttps.works/)
- [TCP/IP Illustrated - 도서](https://www.amazon.com/TCP-Illustrated-Volume-Implementation/dp/0201633469)

---

## 다음 학습

- [HTTP 기초](http-basics.md)
- [DNS 완벽 가이드](dns-guide.md)
- [HTTPS와 보안](https-security.md)

---

*Last updated: 2026-01-05*
