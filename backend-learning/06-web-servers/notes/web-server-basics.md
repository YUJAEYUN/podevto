# 웹 서버 동작 원리

> HTTP 요청이 어떻게 처리되는지 이해하기

## 개요

**웹 서버(Web Server)**는 클라이언트(브라우저)로부터 HTTP 요청을 받아 정적/동적 콘텐츠를 응답하는 소프트웨어입니다.

### 핵심 아이디어

```
"클라이언트가 요청하면, 서버가 응답한다"

┌─────────────────────────────────────────────────────────────────────┐
│                      웹 통신의 기본 구조                              │
│                                                                     │
│   ┌──────────────┐                        ┌──────────────┐          │
│   │   클라이언트   │  ──── HTTP 요청 ────▶  │   웹 서버     │         │
│   │  (브라우저)    │  ◀── HTTP 응답 ────   │  (Nginx 등)  │          │
│   └──────────────┘                        └──────────────┘          │
│                                                                     │
│   예시:                                                              │
│   요청: GET /index.html HTTP/1.1                                    │
│   응답: 200 OK + HTML 문서                                          │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

---

## HTTP 요청 처리 과정 (7단계)

```
┌─────────────────────────────────────────────────────────────────────────┐
│                        HTTP 요청 → 응답 전체 흐름                        │
│                                                                         │
│  [1] URL 입력          [2] DNS 조회          [3] TCP 연결               │
│  www.example.com  →   IP 주소 획득    →   3-Way Handshake              │
│                       (93.184.216.34)                                   │
│                                                                         │
│  [4] HTTP 요청 전송    [5] 서버 처리         [6] HTTP 응답               │
│  GET /page HTTP/1.1 → DB조회/파일읽기  →   200 OK + 데이터              │
│                                                                         │
│  [7] 브라우저 렌더링                                                     │
│  HTML/CSS/JS 파싱 → 화면 표시                                           │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### 1단계: URL 입력

```
사용자가 브라우저에 URL 입력
─────────────────────────────────────────
https://www.example.com/products/123
  │         │              │
  │         │              └── 경로 (Path)
  │         └── 도메인 (Domain)
  └── 프로토콜 (Protocol)
```

### 2단계: DNS 조회

```
도메인 이름 → IP 주소 변환
─────────────────────────────────────────
www.example.com → 93.184.216.34

┌──────────┐     ┌──────────┐     ┌──────────┐
│ 브라우저  │ ──▶ │ DNS 서버  │ ──▶ │ IP 반환   │
└──────────┘     └──────────┘     └──────────┘

* 브라우저 캐시 → OS 캐시 → 라우터 → ISP DNS 순서로 조회
* UDP 프로토콜 사용 (빠른 조회)
```

### 3단계: TCP 연결 (3-Way Handshake)

```
클라이언트와 서버 간 연결 수립
─────────────────────────────────────────

클라이언트                          서버
    │                                │
    │ ─────── SYN ─────────────────▶ │  "연결 요청"
    │                                │
    │ ◀────── SYN + ACK ──────────── │  "요청 수락 + 확인"
    │                                │
    │ ─────── ACK ─────────────────▶ │  "확인 완료"
    │                                │
    └────── 연결 수립 완료 ───────────┘
```

### 4단계: HTTP 요청 메시지 전송

```http
GET /products/123 HTTP/1.1
Host: www.example.com
User-Agent: Mozilla/5.0
Accept: text/html
Accept-Language: ko-KR
Connection: keep-alive
```

```
HTTP 요청 메시지 구조
─────────────────────────────────────────
┌─────────────────────────────────────┐
│ 요청 라인 (Request Line)            │
│ GET /products/123 HTTP/1.1          │
├─────────────────────────────────────┤
│ 헤더 (Headers)                      │
│ Host: www.example.com               │
│ User-Agent: Mozilla/5.0             │
│ Accept: text/html                   │
├─────────────────────────────────────┤
│ 본문 (Body) - POST/PUT 요청 시      │
│ {"name": "product", "price": 100}   │
└─────────────────────────────────────┘
```

### 5단계: 서버 요청 처리

```
웹 서버의 요청 처리 분기
─────────────────────────────────────────

                    요청 수신
                       │
                       ▼
              ┌────────────────┐
              │  정적 콘텐츠?   │
              └───────┬────────┘
                      │
          ┌───────────┴───────────┐
          ▼                       ▼
    ┌──────────┐           ┌──────────────┐
    │ 웹 서버   │           │ WAS로 전달    │
    │ 직접 처리 │           │ (동적 처리)   │
    └──────────┘           └──────────────┘
          │                       │
    HTML, CSS, JS,           DB 조회,
    이미지 파일 반환          API 로직 실행
```

### 6단계: HTTP 응답 메시지

```http
HTTP/1.1 200 OK
Content-Type: text/html; charset=UTF-8
Content-Length: 1234
Date: Sat, 21 Dec 2024 12:00:00 GMT

<!DOCTYPE html>
<html>
  <head><title>Product</title></head>
  <body>...</body>
</html>
```

```
주요 HTTP 상태 코드
─────────────────────────────────────────
2XX 성공
├── 200 OK: 요청 성공
├── 201 Created: 리소스 생성 완료
└── 204 No Content: 성공, 응답 본문 없음

3XX 리다이렉션
├── 301 Moved Permanently: 영구 이동
├── 302 Found: 임시 이동
└── 304 Not Modified: 캐시 사용

4XX 클라이언트 오류
├── 400 Bad Request: 잘못된 요청
├── 401 Unauthorized: 인증 필요
├── 403 Forbidden: 권한 없음
└── 404 Not Found: 리소스 없음

5XX 서버 오류
├── 500 Internal Server Error: 서버 내부 오류
├── 502 Bad Gateway: 게이트웨이 오류
└── 503 Service Unavailable: 서비스 이용 불가
```

### 7단계: 브라우저 렌더링

```
브라우저의 렌더링 과정
─────────────────────────────────────────

HTML 파싱 → DOM 트리 구축
     │
CSS 파싱 → CSSOM 트리 구축
     │
     └──▶ 렌더 트리 생성 → 레이아웃 계산 → 페인팅
                                              │
                                              ▼
                                         화면 표시
```

---

## 웹 서버 vs WAS

```
┌─────────────────────────────────────────────────────────────────────────┐
│                        웹 서버와 WAS의 역할 분담                          │
│                                                                         │
│   ┌──────────────────────────────────────────────────────────────┐     │
│   │                        웹 서버 (Nginx)                        │     │
│   │                                                              │     │
│   │   • 정적 콘텐츠 제공 (HTML, CSS, JS, 이미지)                  │     │
│   │   • 리버스 프록시                                             │     │
│   │   • 로드 밸런싱                                               │     │
│   │   • SSL/TLS 종료 (암호화/복호화)                              │     │
│   │   • 캐싱, 압축                                                │     │
│   └──────────────────────────┬───────────────────────────────────┘     │
│                              │                                          │
│                              ▼ 동적 요청 전달 (평문 HTTP)               │
│                                                                         │
│   ┌──────────────────────────────────────────────────────────────┐     │
│   │                    WAS (Node.js, Spring 등)                   │     │
│   │                                                              │     │
│   │   • 비즈니스 로직 처리                                        │     │
│   │   • 데이터베이스 연동                                         │     │
│   │   • 세션 관리                                                 │     │
│   │   • 동적 콘텐츠 생성 (JSON API 응답)                          │     │
│   └──────────────────────────┬───────────────────────────────────┘     │
│                              │                                          │
│                              ▼                                          │
│                       ┌──────────────┐                                  │
│                       │  데이터베이스  │                                 │
│                       └──────────────┘                                  │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

| 구분 | 웹 서버 | WAS |
|------|---------|-----|
| **역할** | 정적 콘텐츠 제공, 프록시 | 동적 콘텐츠 생성, 비즈니스 로직 |
| **예시** | Nginx, Apache | Node.js/NestJS, Spring, Django |
| **처리 속도** | 매우 빠름 | 상대적으로 느림 |
| **부하** | 낮음 | 높음 (로직, DB 처리) |
| **SSL 처리** | 담당 (종료점) | 보통 안 함 |

### 왜 분리하는가?

```
분리의 이점:
─────────────────────────────────────────
1. 성능 최적화
   - 정적 파일은 Nginx가 빠르게 처리
   - WAS는 비즈니스 로직에만 집중

2. 보안
   - Nginx가 SSL/TLS 처리 → WAS는 내부망에서 평문 통신
   - WAS가 직접 외부에 노출되지 않음

3. 확장성
   - WAS만 여러 대로 늘리고 Nginx가 로드밸런싱
   - 각각 독립적으로 스케일링 가능

4. 유지보수
   - WAS 재시작해도 Nginx는 계속 서비스
   - 설정 변경, 배포가 유연해짐
```

---

## 실무 배포 패턴

### 패턴 1: 단일 서버 (풀스택)

```
┌─────────────────────────────────────────────────────────────┐
│                        단일 서버                             │
│                                                             │
│   ┌─────────────────────────────────────────────────────┐  │
│   │                      Nginx                           │  │
│   │                                                     │  │
│   │   /           → React 빌드 파일 (정적)              │  │
│   │   /static     → CSS, JS, 이미지                     │  │
│   │   /api/*      → proxy_pass → WAS:3000              │  │
│   └─────────────────────────────────────────────────────┘  │
│                          │                                  │
│                          ▼                                  │
│   ┌─────────────────────────────────────────────────────┐  │
│   │              WAS (NestJS, Spring 등)                 │  │
│   └─────────────────────────────────────────────────────┘  │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 패턴 2: 프론트/백엔드 분리 (일반적)

```
┌───────────────────────────────────────────────────────────────────────┐
│                        프론트/백엔드 분리 구조                          │
│                                                                       │
│   ┌─────────────────┐              ┌─────────────────────────────┐   │
│   │    프론트엔드     │              │         백엔드 서버          │   │
│   │                 │              │                             │   │
│   │  Vercel / S3    │              │  ┌─────────────────────┐   │   │
│   │  + CloudFront   │   ───API───▶ │  │       Nginx         │   │   │
│   │                 │              │  │  (리버스 프록시)      │   │   │
│   │  React/Vue 빌드  │              │  │  (SSL 종료)          │   │   │
│   │  정적 파일 호스팅 │              │  └──────────┬──────────┘   │   │
│   └─────────────────┘              │             │              │   │
│                                    │             ▼              │   │
│                                    │  ┌─────────────────────┐   │   │
│                                    │  │   WAS (NestJS 등)   │   │   │
│                                    │  │   localhost:3000    │   │   │
│                                    │  └─────────────────────┘   │   │
│                                    │                             │   │
│                                    └─────────────────────────────┘   │
│                                                                       │
└───────────────────────────────────────────────────────────────────────┘
```

### 패턴 3: 모바일 앱 백엔드

```
모바일 앱 (React Native, Flutter)의 경우:
─────────────────────────────────────────
• 앱 자체가 클라이언트 → 정적 HTML 서빙 불필요
• Nginx는 순수하게 리버스 프록시 + SSL 종료 역할만 수행
• WAS가 JSON API만 제공

┌──────────────┐      HTTPS       ┌──────────┐      HTTP      ┌─────────┐
│  모바일 앱    │ ───────────────▶ │  Nginx   │ ─────────────▶ │  WAS    │
│ (RN/Flutter) │ ◀─────────────── │ (SSL종료) │ ◀───────────── │ (API)   │
└──────────────┘    암호화 통신    └──────────┘   평문 (내부망)  └─────────┘
```

---

## 핵심 정리

1. **HTTP는 요청-응답 프로토콜**
   - 클라이언트가 요청하면 서버가 응답
   - Stateless (상태 비저장)

2. **7단계 처리 과정**
   - URL → DNS → TCP → 요청 → 처리 → 응답 → 렌더링

3. **웹 서버와 WAS 분리**
   - 정적 파일: 웹 서버 (Nginx)가 빠르게 처리
   - 동적 로직: WAS (NestJS, Spring)가 처리
   - SSL/TLS: Nginx가 종료점 역할

4. **실무 배포 패턴**
   - 단일 서버: Nginx가 정적 + API 프록시 모두 처리
   - 분리 구조: 프론트(Vercel/S3) + 백엔드(Nginx+WAS)
   - 모바일: Nginx는 순수 리버스 프록시 + SSL 종료

5. **상태 코드로 결과 전달**
   - 2XX 성공, 4XX 클라이언트 오류, 5XX 서버 오류

---

## 관련 노트

- [Nginx 완벽 가이드](nginx-guide.md) - 아키텍처, 설정, 로드밸런싱
- [HTTPS/SSL/TLS 완벽 가이드](https-ssl-tls-guide.md) - 암호화, 인증서, 핸드셰이크

---

## 참고 자료

- [HTTP 개요 | MDN Web Docs](https://developer.mozilla.org/ko/docs/Web/HTTP/Guides/Overview)
- [웹의 동작 원리 | TCP School](https://www.tcpschool.com/webbasic/works)
- [HTTP 요청과 서버 처리 과정 이해하기 | F-Lab](https://f-lab.kr/insight/understanding-http-request-and-server-processing-20240817)
- [웹 서버와 WAS의 차이점 | Velog](https://velog.io/@moonblue/웹-서버와-WAS의-차이점)
- [Web Server와 WAS의 차이 | gyoogle](https://gyoogle.dev/blog/web-knowledge/Web%20Server%EC%99%80%20WAS%EC%9D%98%20%EC%B0%A8%EC%9D%B4.html)

---

*마지막 업데이트: 2025-12-21*
