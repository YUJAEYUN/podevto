# AWS 로드밸런서 완벽 가이드

> ALB vs NLB vs CLB - 언제 무엇을 써야 하나? 서버 1대인데도 필요한가?

## 목차
1. [로드밸런서가 왜 필요한가?](#로드밸런서가-왜-필요한가)
2. [ALB vs NLB vs CLB 완벽 비교](#alb-vs-nlb-vs-clb-완벽-비교)
3. [Application Load Balancer (ALB) 완벽 이해](#application-load-balancer-alb-완벽-이해)
4. [Network Load Balancer (NLB) 완벽 이해](#network-load-balancer-nlb-완벽-이해)
5. [Health Check와 Connection Draining](#health-check와-connection-draining)
6. [서버 1대인데도 ALB가 필요한 이유](#서버-1대인데도-alb가-필요한-이유)
7. [실전 시나리오와 비용](#실전-시나리오와-비용)

---

## 로드밸런서가 왜 필요한가?

### 당신이 했던 질문

```
"서버 1대만 사용하는데도 로드밸런서가 필요한가?"
"Auto Scaling 안 쓰는데 ALB를 왜 써야 해?"
"Internet Gateway만으로는 안 되는 이유가 뭐야?"
```

### Internet Gateway만 사용하는 경우

```
┌──────────────────────────────────────────────────────────┐
│                       문제 상황                          │
├──────────────────────────────────────────────────────────┤
│                                                          │
│  사용자 → IGW → EC2 (단일 서버)                          │
│                                                          │
│  ❌ 문제점:                                              │
│                                                          │
│  1️⃣ 서버 장애 시 다운타임                               │
│     ┌────────────────────────────────────┐             │
│     │ EC2 죽음 → 서비스 중단             │             │
│     │ 수동으로 서버 재시작할 때까지      │             │
│     │ 사용자는 접속 불가 ❌              │             │
│     └────────────────────────────────────┘             │
│                                                          │
│  2️⃣ 배포 시 다운타임                                    │
│     ┌────────────────────────────────────┐             │
│     │ 새 버전 배포 → 서버 재시작         │             │
│     │ 30초~1분 서비스 중단 ❌            │             │
│     └────────────────────────────────────┘             │
│                                                          │
│  3️⃣ SSL 인증서 관리 복잡                                │
│     ┌────────────────────────────────────┐             │
│     │ 각 EC2마다 인증서 설치             │             │
│     │ 갱신 시 모든 서버 수동 업데이트    │             │
│     └────────────────────────────────────┘             │
│                                                          │
│  4️⃣ IP 변경 문제                                        │
│     ┌────────────────────────────────────┐             │
│     │ EC2 재시작 → Public IP 변경        │             │
│     │ DNS 업데이트 필요                  │             │
│     │ (Elastic IP 쓰면 비용 발생)        │             │
│     └────────────────────────────────────┘             │
│                                                          │
│  5️⃣ 확장 어려움                                         │
│     ┌────────────────────────────────────┐             │
│     │ 트래픽 증가 시 서버 추가하려면     │             │
│     │ DNS Round Robin 수동 설정          │             │
│     │ Health Check 없음                  │             │
│     └────────────────────────────────────┘             │
│                                                          │
└──────────────────────────────────────────────────────────┘
```

### 로드밸런서 사용 시

```
┌──────────────────────────────────────────────────────────┐
│                     해결된 문제                          │
├──────────────────────────────────────────────────────────┤
│                                                          │
│  사용자 → ALB → EC2 (또는 여러 대)                       │
│                                                          │
│  ✅ 해결:                                                │
│                                                          │
│  1️⃣ 자동 장애 복구                                      │
│     ┌────────────────────────────────────┐             │
│     │ Health Check로 서버 상태 감지      │             │
│     │ 장애 발생 → 자동으로 트래픽 차단   │             │
│     │ 정상 서버로만 요청 전달 ✅         │             │
│     └────────────────────────────────────┘             │
│                                                          │
│  2️⃣ 무중단 배포 가능                                    │
│     ┌────────────────────────────────────┐             │
│     │ 새 서버 띄우기 → Health Check 통과 │             │
│     │ → ALB가 트래픽 전환                │             │
│     │ → 구 서버 종료 (Connection Draining)│            │
│     │ 다운타임 0초! ✅                   │             │
│     └────────────────────────────────────┘             │
│                                                          │
│  3️⃣ SSL 인증서 중앙 관리                                │
│     ┌────────────────────────────────────┐             │
│     │ ALB에만 인증서 설치                │             │
│     │ EC2는 HTTP만 사용                  │             │
│     │ 갱신도 ALB에서만 ✅                │             │
│     └────────────────────────────────────┘             │
│                                                          │
│  4️⃣ 고정 DNS 제공                                       │
│     ┌────────────────────────────────────┐             │
│     │ ALB DNS: my-alb-xxx.elb.amazonaws.com │          │
│     │ 절대 변경 안 됨 ✅                 │             │
│     │ Route 53에 CNAME 한 번만 설정      │             │
│     └────────────────────────────────────┘             │
│                                                          │
│  5️⃣ 쉬운 확장                                           │
│     ┌────────────────────────────────────┐             │
│     │ Auto Scaling 완벽 지원             │             │
│     │ 서버 추가/제거 자동 처리           │             │
│     │ Health Check로 안전하게 관리 ✅    │             │
│     └────────────────────────────────────┘             │
│                                                          │
└──────────────────────────────────────────────────────────┘
```

---

## ALB vs NLB vs CLB 완벽 비교

### 3가지 로드밸런서 한눈에

| 특성 | ALB | NLB | CLB |
|------|-----|-----|-----|
| **OSI 계층** | Layer 7 (Application) | Layer 4 (Transport) | Layer 4/7 |
| **프로토콜** | HTTP, HTTPS, WebSocket | TCP, UDP, TLS | TCP, HTTP, HTTPS |
| **라우팅** | URL, 헤더, 쿼리스트링 기반 | IP/포트 기반만 | 기본적인 라우팅만 |
| **성능** | 초당 수만 요청 | 초당 수백만 요청 | 낮음 |
| **지연시간** | ms 단위 | μs 단위 (마이크로초) | 높음 |
| **고정 IP** | ❌ (DNS만) | ✅ (Elastic IP 연결 가능) | ❌ |
| **WebSocket** | ✅ | ✅ | ❌ |
| **HTTP/2** | ✅ | ❌ | ❌ |
| **SSL 종료** | ✅ | ✅ | ✅ |
| **Path 라우팅** | ✅ `/api` → 서버1<br>`/web` → 서버2 | ❌ | ❌ |
| **Host 라우팅** | ✅ `api.example.com` → 서버1<br>`web.example.com` → 서버2 | ❌ | ❌ |
| **타겟 타입** | Instance, IP, Lambda | Instance, IP, ALB | Instance만 |
| **가격** | $16.2/월<br>+ LCU 비용 | $16.2/월<br>+ LCU 비용 | $18.25/월 |
| **권장 사용** | 웹 애플리케이션<br>API 서버 | 게임 서버<br>IoT<br>초고성능 필요 시 | ❌ 사용 중단 권장 |

### 계층별 동작 방식

```
┌─────────────────────────────────────────────────────────┐
│               OSI 7 Layer Model                         │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  Layer 7 - Application  (HTTP, HTTPS, DNS, FTP...)     │
│  ┌──────────────────────────────────────────────────┐  │
│  │         ALB가 이 계층에서 동작 ✅                 │  │
│  │  • URL 경로 확인: /api, /images                  │  │
│  │  • HTTP 헤더 확인: User-Agent, Cookie            │  │
│  │  • 쿼리스트링 확인: ?user=123                    │  │
│  │  • WebSocket Upgrade 처리                        │  │
│  └──────────────────────────────────────────────────┘  │
│                                                         │
│  Layer 6 - Presentation (SSL/TLS 암호화)               │
│  Layer 5 - Session                                      │
│  Layer 4 - Transport    (TCP, UDP, Port)               │
│  ┌──────────────────────────────────────────────────┐  │
│  │         NLB가 이 계층에서 동작 ✅                 │  │
│  │  • IP 주소와 포트만 확인                         │  │
│  │  • TCP/UDP 패킷 그대로 전달                      │  │
│  │  • 내용물 확인 안 함 (빠름!)                     │  │
│  └──────────────────────────────────────────────────┘  │
│                                                         │
│  Layer 3 - Network      (IP, Routing)                  │
│  Layer 2 - Data Link    (MAC, Switch)                  │
│  Layer 1 - Physical     (Cable, Signal)                │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

### 언제 무엇을 쓰나?

```
✅ ALB 사용:
• 웹 애플리케이션 (React, Vue, Angular...)
• REST API 서버 (NestJS, Express, FastAPI...)
• 마이크로서비스 (Path 기반 라우팅)
• WebSocket 채팅 서버
• HTTP/2 필요한 경우

✅ NLB 사용:
• 게임 서버 (UDP, 낮은 지연시간 필수)
• IoT 디바이스 (수백만 연결)
• TCP/UDP 기반 서비스 (MQTT, gRPC)
• 고정 IP 필요한 경우 (화이트리스트)
• 초고성능 필요 (ALB보다 10배 이상 빠름)

❌ CLB 사용 중단:
• 2009년 출시된 구형 모델
• ALB/NLB로 마이그레이션 권장
• 새로 만들지 말 것!
```

---

## Application Load Balancer (ALB) 완벽 이해

### ALB 아키텍처

```
                         Internet
                            │
                            ▼
              ┌─────────────────────────┐
              │   Application Load      │
              │      Balancer (ALB)     │
              │                         │
              │  • 고정 DNS 제공        │
              │  • SSL 종료             │
              │  • Path 기반 라우팅     │
              │  • Health Check         │
              └────────┬────────────────┘
                       │
          ┌────────────┼────────────┐
          │            │            │
          ▼            ▼            ▼
    ┌─────────┐  ┌─────────┐  ┌─────────┐
    │ Target  │  │ Target  │  │ Target  │
    │ Group 1 │  │ Group 2 │  │ Group 3 │
    └────┬────┘  └────┬────┘  └────┬────┘
         │            │            │
    /api/*       /images/*     default
```

### Listener와 Listener Rules

```
Listener = ALB의 "귀" (어떤 포트로 들어오는지 듣는 곳)

┌──────────────────────────────────────────────────────┐
│ Listener 1: 포트 80 (HTTP)                           │
│  ├─ Rule 1: 모든 요청 → HTTPS(443)로 리다이렉트      │
└──────────────────────────────────────────────────────┘

┌──────────────────────────────────────────────────────┐
│ Listener 2: 포트 443 (HTTPS)                         │
│  ├─ Rule 1 (우선순위 1):                             │
│  │   조건: Path = /api/*                             │
│  │   동작: target-group-api로 전달                   │
│  │                                                   │
│  ├─ Rule 2 (우선순위 2):                             │
│  │   조건: Path = /images/*                          │
│  │   동작: target-group-static로 전달                │
│  │                                                   │
│  ├─ Rule 3 (우선순위 3):                             │
│  │   조건: Header[User-Agent] = Mobile*              │
│  │   동작: target-group-mobile로 전달                │
│  │                                                   │
│  └─ Default Rule (마지막):                           │
│      조건: 없음 (모든 요청)                          │
│      동작: target-group-web로 전달                   │
└──────────────────────────────────────────────────────┘

💡 규칙은 우선순위 순서대로 평가
   매칭되면 즉시 처리 (나머지 규칙 건너뜀)
```

### Target Group

```
Target Group = 실제 서버들의 그룹

┌──────────────────────────────────────────────────────┐
│ Target Group: tg-api                                 │
├──────────────────────────────────────────────────────┤
│                                                      │
│ Targets:                                             │
│  ├─ EC2 Instance i-abc123 (10.0.1.10:8080) ✅       │
│  ├─ EC2 Instance i-def456 (10.0.1.20:8080) ✅       │
│  └─ EC2 Instance i-ghi789 (10.0.1.30:8080) ❌ Unhealthy │
│                                                      │
│ Health Check:                                        │
│  • Protocol: HTTP                                    │
│  • Path: /health                                     │
│  • Interval: 30초마다                                │
│  • Timeout: 5초                                      │
│  • Healthy threshold: 연속 2회 성공                  │
│  • Unhealthy threshold: 연속 2회 실패                │
│                                                      │
│ Load Balancing Algorithm:                            │
│  • Round Robin (기본값)                              │
│  • Least Outstanding Requests (최소 요청)            │
│                                                      │
│ Stickiness (세션 고정):                              │
│  • Duration: 1 hour                                  │
│  • 같은 사용자는 같은 서버로 ✅                      │
│                                                      │
│ Deregistration Delay (Connection Draining):          │
│  • 300초 (기본값)                                    │
│  • 서버 제거 시 기존 연결 완료 대기                  │
│                                                      │
└──────────────────────────────────────────────────────┘
```

### Path 기반 라우팅 실전 예시

```
시나리오: 마이크로서비스 아키텍처

사용자 요청:
1. https://example.com/api/users
2. https://example.com/web/dashboard
3. https://example.com/images/logo.png

ALB 처리:
┌──────────────────────────────────────────────────────┐
│ 1. /api/users                                        │
│    → Listener Rule: Path = /api/*                    │
│    → Target Group: tg-api-service                    │
│    → Servers:                                        │
│       • 10.0.1.10:3000 (NestJS)                      │
│       • 10.0.1.20:3000 (NestJS)                      │
└──────────────────────────────────────────────────────┘

┌──────────────────────────────────────────────────────┐
│ 2. /web/dashboard                                    │
│    → Listener Rule: Path = /web/*                    │
│    → Target Group: tg-web-service                    │
│    → Servers:                                        │
│       • 10.0.2.10:8080 (React SPA)                   │
│       • 10.0.2.20:8080 (React SPA)                   │
└──────────────────────────────────────────────────────┘

┌──────────────────────────────────────────────────────┐
│ 3. /images/logo.png                                  │
│    → Listener Rule: Path = /images/*                 │
│    → Target Group: tg-static                         │
│    → Servers:                                        │
│       • 10.0.3.10:80 (Nginx static)                  │
└──────────────────────────────────────────────────────┘

✅ 장점:
• 서비스별로 독립적인 서버 운영
• 각 서비스는 자기 코드만 관리
• 배포도 독립적 (api 배포해도 web 영향 없음)
```

### Host 기반 라우팅 실전 예시

```
시나리오: 멀티 도메인 서비스

사용자 요청:
1. https://api.example.com/users
2. https://www.example.com/
3. https://admin.example.com/dashboard

ALB 처리:
┌──────────────────────────────────────────────────────┐
│ 1. api.example.com                                   │
│    → Listener Rule: Host = api.example.com           │
│    → Target Group: tg-api                            │
│    → Backend: NestJS API 서버                        │
└──────────────────────────────────────────────────────┘

┌──────────────────────────────────────────────────────┐
│ 2. www.example.com                                   │
│    → Listener Rule: Host = www.example.com           │
│    → Target Group: tg-web                            │
│    → Backend: React 프론트엔드                       │
└──────────────────────────────────────────────────────┘

┌──────────────────────────────────────────────────────┐
│ 3. admin.example.com                                 │
│    → Listener Rule: Host = admin.example.com         │
│    → Target Group: tg-admin                          │
│    → Backend: 어드민 대시보드                        │
└──────────────────────────────────────────────────────┘

✅ 모든 도메인이 하나의 ALB 사용
   → 비용 절감! (ALB 1개만)
```

### SSL 종료 (SSL Termination)

```
외부 (HTTPS) → ALB → 내부 (HTTP)

┌──────────────────────────────────────────────────────┐
│                    SSL 종료 흐름                     │
├──────────────────────────────────────────────────────┤
│                                                      │
│ 1️⃣ 사용자 → ALB                                     │
│    ┌──────────────────────────────────────┐         │
│    │ HTTPS (암호화됨)                     │         │
│    │ • TLS 핸드셰이크                     │         │
│    │ • 인증서 검증                        │         │
│    │ • 암호화된 데이터 전송               │         │
│    └──────────────────────────────────────┘         │
│                                                      │
│ 2️⃣ ALB에서 복호화                                   │
│    ┌──────────────────────────────────────┐         │
│    │ ALB가 SSL 인증서로 복호화            │         │
│    │ 평문 HTTP 요청 확인 가능             │         │
│    │ → Path, Header 보고 라우팅 결정      │         │
│    └──────────────────────────────────────┘         │
│                                                      │
│ 3️⃣ ALB → Backend                                    │
│    ┌──────────────────────────────────────┐         │
│    │ HTTP (평문)                          │         │
│    │ • VPC 내부망이라 안전                │         │
│    │ • 서버 CPU 부담 감소 ✅              │         │
│    └──────────────────────────────────────┘         │
│                                                      │
│ 4️⃣ Backend → ALB                                    │
│    ┌──────────────────────────────────────┐         │
│    │ HTTP 응답 (평문)                     │         │
│    └──────────────────────────────────────┘         │
│                                                      │
│ 5️⃣ ALB에서 다시 암호화                              │
│    ┌──────────────────────────────────────┐         │
│    │ HTTPS로 암호화                       │         │
│    └──────────────────────────────────────┘         │
│                                                      │
│ 6️⃣ ALB → 사용자                                     │
│    ┌──────────────────────────────────────┐         │
│    │ HTTPS (암호화됨)                     │         │
│    └──────────────────────────────────────┘         │
│                                                      │
└──────────────────────────────────────────────────────┘

✅ 장점:
• 인증서를 ALB에서만 관리 (갱신 쉬움)
• Backend 서버 CPU 부담 감소 (암호화 안 해도 됨)
• 여러 서버 있어도 인증서 1개만 필요
```

---

## Network Load Balancer (NLB) 완벽 이해

### NLB 특징

```
Layer 4 로드밸런서 = TCP/UDP 패킷만 보고 전달

┌──────────────────────────────────────────────────────┐
│               NLB vs ALB 동작 비교                   │
├──────────────────────────────────────────────────────┤
│                                                      │
│ ALB (Layer 7):                                       │
│  ┌────────────────────────────────────────┐         │
│  │ 1. TCP 연결 확립                       │         │
│  │ 2. HTTP 요청 전체 읽기                 │         │
│  │ 3. URL, Header 분석 (시간 소요)        │         │
│  │ 4. 어느 서버로 보낼지 결정             │         │
│  │ 5. 서버와 새 TCP 연결                  │         │
│  │ 6. 요청 전달                           │         │
│  └────────────────────────────────────────┘         │
│  지연시간: ms 단위                                   │
│                                                      │
│ NLB (Layer 4):                                       │
│  ┌────────────────────────────────────────┐         │
│  │ 1. TCP SYN 패킷 도착                   │         │
│  │ 2. IP/Port만 확인 (내용 안 봄!)        │         │
│  │ 3. 서버로 즉시 전달                    │         │
│  └────────────────────────────────────────┘         │
│  지연시간: μs 단위 (마이크로초)                      │
│                                                      │
└──────────────────────────────────────────────────────┘

💡 NLB는 "패킷 전달자" 역할만
   내용물은 관심 없고, 주소만 보고 전달
```

### NLB 사용 사례

```
✅ 게임 서버:

┌──────────────────────────────────────────────────────┐
│ 요구사항:                                            │
│ • UDP 프로토콜 사용                                  │
│ • 초저지연 (1ms 이하)                                │
│ • 초당 수백만 패킷                                   │
│                                                      │
│ 사용자 (게임 클라이언트)                             │
│       │                                              │
│       ▼ UDP:7777                                     │
│ ┌─────────────┐                                      │
│ │     NLB     │                                      │
│ └──────┬──────┘                                      │
│        │                                             │
│    ┌───┴───┬───────┬───────┐                        │
│    ▼       ▼       ▼       ▼                        │
│ Game1   Game2   Game3   Game4                        │
│ :7777   :7777   :7777   :7777                        │
│                                                      │
│ ✅ NLB 필수 (ALB는 UDP 지원 안 함)                   │
└──────────────────────────────────────────────────────┘

✅ IoT 디바이스:

┌──────────────────────────────────────────────────────┐
│ 요구사항:                                            │
│ • MQTT 프로토콜 (TCP 기반)                           │
│ • 수백만 디바이스 동시 연결                          │
│ • 낮은 지연시간                                      │
│                                                      │
│ IoT 디바이스 (수백만 개)                             │
│       │                                              │
│       ▼ TCP:1883 (MQTT)                              │
│ ┌─────────────┐                                      │
│ │     NLB     │                                      │
│ └──────┬──────┘                                      │
│        │                                             │
│    ┌───┴───┬───────┬───────┐                        │
│    ▼       ▼       ▼       ▼                        │
│ MQTT1   MQTT2   MQTT3   MQTT4                        │
│ Broker  Broker  Broker  Broker                       │
│                                                      │
│ ✅ NLB 권장 (ALB보다 10배 빠름)                      │
└──────────────────────────────────────────────────────┘

✅ 고정 IP 필요:

┌──────────────────────────────────────────────────────┐
│ 요구사항:                                            │
│ • 파트너사 화이트리스트에 IP 등록                    │
│ • IP 변경 불가                                       │
│                                                      │
│ NLB + Elastic IP:                                    │
│  ┌──────────────────────────────┐                   │
│  │ NLB: 3.35.50.100 (고정 EIP)  │                   │
│  └────────┬─────────────────────┘                   │
│           │                                          │
│       Backends                                       │
│                                                      │
│ ✅ NLB만 EIP 연결 가능 (ALB는 불가)                  │
└──────────────────────────────────────────────────────┘
```

### NLB 주의사항

```
⚠️  NLB 사용 시 주의:

1️⃣ 보안그룹 설정이 다름
   ┌────────────────────────────────────────┐
   │ ALB: ALB 자체에 보안그룹 적용          │
   │      클라이언트 IP를 ALB가 체크        │
   │                                        │
   │ NLB: 보안그룹 없음!                    │
   │      클라이언트 IP가 그대로 EC2에 전달 │
   │      → EC2 보안그룹에서 직접 관리      │
   └────────────────────────────────────────┘

2️⃣ X-Forwarded-For 헤더 없음
   ┌────────────────────────────────────────┐
   │ ALB: HTTP 헤더에 클라이언트 IP 추가    │
   │      X-Forwarded-For: 211.234.123.45   │
   │                                        │
   │ NLB: TCP만 전달, 헤더 수정 안 함       │
   │      애플리케이션에서 직접 확인        │
   └────────────────────────────────────────┘

3️⃣ SSL 인증서 관리
   ┌────────────────────────────────────────┐
   │ NLB TLS Listener:                      │
   │ • TLS 종료 가능 (ALB처럼)              │
   │ • 또는 TLS 패스스루 (암호화 그대로 전달)│
   │                                        │
   │ 선택에 따라 Backend 설정 달라짐        │
   └────────────────────────────────────────┘
```

---

## Health Check와 Connection Draining

### Health Check 완벽 이해

```
Health Check = ALB/NLB가 서버 상태를 주기적으로 확인

┌──────────────────────────────────────────────────────┐
│                Health Check 프로세스                 │
├──────────────────────────────────────────────────────┤
│                                                      │
│ 설정:                                                │
│  • Protocol: HTTP                                    │
│  • Path: /health                                     │
│  • Port: 8080                                        │
│  • Interval: 30초                                    │
│  • Timeout: 5초                                      │
│  • Healthy threshold: 2 (연속 2회 성공)              │
│  • Unhealthy threshold: 2 (연속 2회 실패)            │
│  • Success codes: 200                                │
│                                                      │
│ 동작:                                                │
│  00:00  ALB → GET /health → EC2                      │
│         ← 200 OK (응답 0.5초)  ✅                    │
│                                                      │
│  00:30  ALB → GET /health → EC2                      │
│         ← 200 OK (응답 0.5초)  ✅                    │
│         → 상태: Healthy (2회 연속 성공)              │
│                                                      │
│  01:00  ALB → GET /health → EC2                      │
│         ← Timeout (5초 경과)  ❌                     │
│         → 아직 Healthy (1회 실패는 괜찮음)           │
│                                                      │
│  01:30  ALB → GET /health → EC2                      │
│         ← Timeout (5초 경과)  ❌                     │
│         → 상태: Unhealthy (2회 연속 실패)            │
│         → 🚨 이 서버로 트래픽 전송 중단!             │
│                                                      │
│  02:00  ALB → GET /health → EC2                      │
│         ← 200 OK (서버 복구됨)  ✅                   │
│         → 아직 Unhealthy (1회 성공은 부족)           │
│                                                      │
│  02:30  ALB → GET /health → EC2                      │
│         ← 200 OK  ✅                                 │
│         → 상태: Healthy (2회 연속 성공)              │
│         → ✅ 다시 트래픽 전송 시작!                  │
│                                                      │
└──────────────────────────────────────────────────────┘
```

### Health Check 엔드포인트 구현

```javascript
// NestJS 예시

@Controller('health')
export class HealthController {
  constructor(
    private readonly dbService: DatabaseService,
    private readonly redisService: RedisService,
  ) {}

  @Get()
  async check(): Promise<{ status: string }> {
    // 1️⃣ 간단한 Health Check (권장 - 빠름)
    return { status: 'ok' };

    // 2️⃣ 상세한 Health Check (선택적)
    try {
      // DB 연결 확인
      await this.dbService.ping();

      // Redis 연결 확인
      await this.redisService.ping();

      return {
        status: 'ok',
        database: 'connected',
        redis: 'connected',
        timestamp: new Date().toISOString()
      };
    } catch (error) {
      // ⚠️  503 또는 500 반환 → Unhealthy로 판정
      throw new HttpException(
        { status: 'error', message: error.message },
        HttpStatus.SERVICE_UNAVAILABLE
      );
    }
  }
}

// ⚠️  주의사항:
// • Health Check는 매우 자주 호출됨 (30초마다)
// • 너무 무거운 로직은 피할 것 (DB 쿼리 등)
// • 로그 남기면 로그 파일 폭증 가능
```

### Connection Draining (Deregistration Delay)

```
Connection Draining = 서버 제거 시 기존 연결을 안전하게 종료

시나리오: 새 버전 배포로 서버 교체

┌──────────────────────────────────────────────────────┐
│                  배포 프로세스                       │
├──────────────────────────────────────────────────────┤
│                                                      │
│ 1️⃣ 새 서버 시작                                     │
│    ┌──────────────────────────────────────┐         │
│    │ EC2-new 시작                         │         │
│    │ → Health Check 대기 (60초)           │         │
│    │ → Healthy 상태로 전환 ✅             │         │
│    │ → ALB가 트래픽 전송 시작             │         │
│    └──────────────────────────────────────┘         │
│                                                      │
│ 2️⃣ 구 서버 제거 시작                                │
│    ┌──────────────────────────────────────┐         │
│    │ ALB에서 EC2-old를 Draining 상태로   │         │
│    │                                      │         │
│    │ 현재 연결된 요청:                    │         │
│    │ • User 1: 파일 업로드 중 (80% 완료)  │         │
│    │ • User 2: 긴 쿼리 처리 중 (30초 남음)│         │
│    │ • User 3: WebSocket 연결 중          │         │
│    └──────────────────────────────────────┘         │
│                                                      │
│ 3️⃣ Draining 동작                                    │
│    ┌──────────────────────────────────────┐         │
│    │ ✅ 기존 연결: 계속 처리 (종료까지)   │         │
│    │    • User 1: 업로드 완료될 때까지    │         │
│    │    • User 2: 쿼리 끝날 때까지        │         │
│    │    • User 3: 연결 유지               │         │
│    │                                      │         │
│    │ ❌ 새 요청: 받지 않음                │         │
│    │    → 모든 새 요청은 EC2-new로        │         │
│    └──────────────────────────────────────┘         │
│                                                      │
│ 4️⃣ 시간 경과                                        │
│    ┌──────────────────────────────────────┐         │
│    │ T+60초: User 1 업로드 완료 ✅        │         │
│    │ T+90초: User 2 쿼리 완료 ✅          │         │
│    │ T+300초: User 3 타임아웃으로 종료 ✅ │         │
│    │                                      │         │
│    │ 또는                                 │         │
│    │ T+300초: Deregistration Delay 만료  │         │
│    │         → 강제 종료                  │         │
│    └──────────────────────────────────────┘         │
│                                                      │
│ 5️⃣ 서버 종료                                        │
│    ┌──────────────────────────────────────┐         │
│    │ 모든 연결 종료됨                     │         │
│    │ → EC2-old 안전하게 종료 ✅           │         │
│    └──────────────────────────────────────┘         │
│                                                      │
└──────────────────────────────────────────────────────┘

⚙️  Deregistration Delay 설정:
• 기본값: 300초 (5분)
• 권장값: 30~60초 (대부분의 요청은 짧음)
• 0으로 설정: 즉시 강제 종료 (비권장)
```

### Health Check + Connection Draining 실전 시나리오

```
시나리오: 메모리 누수로 서버 다운

00:00  서버 정상 동작 ✅
       • Health Check: 200 OK
       • 활성 연결: 500개

00:10  메모리 누수 시작
       • 메모리 사용률: 50% → 70%
       • Health Check: 여전히 200 OK ✅
       • 활성 연결: 600개

00:20  서버 느려짐
       • 메모리 사용률: 90%
       • Health Check: Timeout (5초 초과) ❌
       • 아직 Healthy (1회 실패)
       • 활성 연결: 650개

00:30  서버 거의 죽음
       • 메모리 사용률: 95%
       • Health Check: Timeout ❌
       • 상태: Unhealthy (2회 연속 실패) 🚨
       • ALB가 새 트래픽 전송 중단!
       • 기존 연결: 650개 → Draining 시작

00:31  Draining 중
       • 새 요청: 다른 서버로 전달 ✅
       • 기존 요청: 천천히 완료 중
       • 활성 연결: 650 → 500 → 300 → 100...

01:00  모든 연결 종료
       • 활성 연결: 0개
       • 서버 안전하게 재시작 가능 ✅

✅ 사용자 영향: 최소화!
   • 새 요청은 즉시 정상 서버로
   • 기존 요청은 완료될 때까지 처리
```

---

## 서버 1대인데도 ALB가 필요한 이유

### 당신의 상황

```
현재 구성:
• EC2 1대
• NestJS (8044 포트)
• PostgreSQL (5432 포트)
• Redis (6333 포트)
• Auto Scaling 사용 중 (평소 1대, 부하 시 증가)
```

### ALB 없이 구성 시 문제점

```
❌ 문제 1: 배포 시 다운타임

┌──────────────────────────────────────────────────────┐
│ 배포 프로세스 (ALB 없을 때):                         │
│                                                      │
│ 1. 새 코드 push                                      │
│ 2. 서버 재시작                                       │
│    ┌────────────────────────────────────┐           │
│    │ pm2 reload 또는 docker restart     │           │
│    │ → 5~30초 서비스 중단 ❌            │           │
│    │                                    │           │
│    │ 사용자:                            │           │
│    │ "502 Bad Gateway" 또는 연결 끊김   │           │
│    └────────────────────────────────────┘           │
│                                                      │
│ ✅ ALB 사용 시:                                      │
│    1. Auto Scaling이 새 인스턴스 시작                │
│    2. Health Check 통과할 때까지 대기                │
│    3. 트래픽 전환 (0초 다운타임!)                    │
│    4. 구 인스턴스 Draining 후 종료                   │
└──────────────────────────────────────────────────────┘
```

```
❌ 문제 2: SSL 인증서 관리

┌──────────────────────────────────────────────────────┐
│ ALB 없을 때:                                         │
│                                                      │
│ • Let's Encrypt 인증서를 EC2에 직접 설치             │
│ • 90일마다 갱신 (certbot 설정 필요)                  │
│ • 갱신 시 Nginx reload (잠깐 끊김 가능)              │
│ • 여러 도메인이면 각각 관리                          │
│                                                      │
│ ✅ ALB 사용 시:                                      │
│                                                      │
│ • AWS Certificate Manager (ACM) 무료 인증서          │
│ • 자동 갱신 (신경 안 써도 됨!)                       │
│ • 여러 도메인도 하나의 인증서로                      │
│ • 서버는 HTTP만 사용 (설정 단순화)                   │
└──────────────────────────────────────────────────────┘
```

```
❌ 문제 3: 장애 복구

┌──────────────────────────────────────────────────────┐
│ ALB 없을 때:                                         │
│                                                      │
│ • EC2 죽음 → 서비스 완전 중단 ❌                     │
│ • CloudWatch 알람 받고 수동으로 재시작               │
│ • 복구까지 5~10분 다운타임                           │
│                                                      │
│ ✅ ALB 사용 시:                                      │
│                                                      │
│ • Health Check가 자동 감지 (30초 이내)               │
│ • Auto Scaling이 새 인스턴스 시작                    │
│ • 자동 복구 (사용자는 모름!)                         │
└──────────────────────────────────────────────────────┘
```

```
❌ 문제 4: Auto Scaling 활용 제한

┌──────────────────────────────────────────────────────┐
│ ALB 없을 때:                                         │
│                                                      │
│ • Auto Scaling으로 서버 추가되면?                    │
│   → 새 Public IP 발급                                │
│   → DNS 업데이트 필요 (수동)                         │
│   → TTL 때문에 전파 시간 소요                        │
│                                                      │
│ ✅ ALB 사용 시:                                      │
│                                                      │
│ • Auto Scaling이 서버 추가                           │
│   → ALB가 자동으로 감지하고 트래픽 분산              │
│   → DNS 변경 불필요 (ALB DNS는 고정)                 │
│   → 즉시 부하 분산 시작 ✅                           │
└──────────────────────────────────────────────────────┘
```

### 서버 1대여도 ALB를 써야 하는 이유 정리

```
✅ 1. 무중단 배포
   • Blue-Green 또는 Rolling 배포 가능
   • 새 버전 서버 Health Check 통과 후 전환
   • 다운타임 0초

✅ 2. 자동 장애 복구
   • Health Check로 서버 상태 모니터링
   • 문제 발생 시 Auto Scaling 자동 대응
   • 수동 개입 최소화

✅ 3. SSL 관리 간소화
   • ACM 무료 인증서 (자동 갱신)
   • 서버는 HTTP만 신경 쓰면 됨
   • 복잡한 인증서 설정 불필요

✅ 4. 고정 엔드포인트
   • ALB DNS는 절대 안 바뀜
   • Route 53에 CNAME 한 번만 설정
   • EC2 IP 바뀌어도 영향 없음

✅ 5. Auto Scaling 완벽 지원
   • 서버 추가/제거 자동 처리
   • DNS 변경 불필요
   • 즉시 부하 분산

✅ 6. 향후 확장 대비
   • Path 기반 라우팅 (나중에 추가 가능)
   • 마이크로서비스 전환 쉬움
   • 멀티 AZ 배포 가능
```

### 비용 대비 효과

```
┌──────────────────────────────────────────────────────┐
│              ALB 비용 vs 가치                        │
├──────────────────────────────────────────────────────┤
│                                                      │
│ 비용:                                                │
│  • ALB: $16.2/월 (시간당 $0.0225)                    │
│  • LCU: ~$5/월 (트래픽 적으면)                       │
│  • 합계: 약 $21/월 (₩28,000)                         │
│                                                      │
│ 대체 비용 (ALB 없이):                                │
│  • Elastic IP: $0 (사용 중)                          │
│  • 하지만...                                         │
│    - 배포 시 다운타임 → 매출 손실?                   │
│    - 장애 복구 수동 → 개발자 시간 비용?              │
│    - SSL 인증서 관리 → 시간 비용?                    │
│                                                      │
│ 가치:                                                │
│  • 무중단 배포: 월 10회 × 30초 = 5분 다운타임 방지   │
│  • 자동 복구: 연 2~3회 장애 × 10분 = 30분 절약       │
│  • SSL 관리: 월 1시간 절약                           │
│  • 정신 건강: Priceless 😊                           │
│                                                      │
│ 결론: $21 투자 가치 충분! ✅                         │
│                                                      │
└──────────────────────────────────────────────────────┘
```

### 실전 구성 예시

```
추천 구성: ALB + Auto Scaling (min:1, max:3)

┌──────────────────────────────────────────────────────┐
│                                                      │
│                    Route 53                          │
│         example.com → my-alb-xxx.amazonaws.com       │
│                         │                            │
│                         ▼                            │
│              ┌──────────────────┐                    │
│              │       ALB        │                    │
│              │ • SSL 종료       │                    │
│              │ • Health Check   │                    │
│              └────────┬─────────┘                    │
│                       │                              │
│                       ▼                              │
│              ┌──────────────────┐                    │
│              │  Target Group    │                    │
│              │ • Port: 8044     │                    │
│              │ • Health: /health│                    │
│              └────────┬─────────┘                    │
│                       │                              │
│          ┌────────────┼────────────┐                 │
│          ▼            ▼            ▼                 │
│      ┌──────┐    ┌──────┐    ┌──────┐               │
│      │ EC2-1│    │ EC2-2│    │ EC2-3│               │
│      │(기본)│    │(부하시)│  │(부하시)│             │
│      └──────┘    └──────┘    └──────┘               │
│                                                      │
│ Auto Scaling 정책:                                   │
│  • Desired: 1 (평소)                                 │
│  • Min: 1                                            │
│  • Max: 3                                            │
│  • Scale Up: CPU > 70% (2분 연속)                    │
│  • Scale Down: CPU < 30% (5분 연속)                  │
│                                                      │
│ 비용:                                                │
│  • ALB: $21/월                                       │
│  • EC2 평소: 1대 × $30 = $30/월                      │
│  • EC2 부하시: 3대 × $30 × 10% = $9/월               │
│  • 합계: 약 $60/월                                   │
│                                                      │
│ vs ALB 없이 고정 3대:                                │
│  • EC2: 3대 × $30 = $90/월                           │
│  • 비용 절감: $30/월 ✅                              │
│                                                      │
└──────────────────────────────────────────────────────┘
```

---

## 실전 시나리오와 비용

### 시나리오 1: 스타트업 MVP (소규모)

```
요구사항:
• 초기 사용자 적음 (하루 100명)
• 빠른 배포 필요
• 비용 민감

❌ 비추천: ALB
┌────────────────────────────────────────┐
│ ALB: $21/월                            │
│ EC2: $7.5/월 (t3.micro)                │
│ 합계: $28.5/월                         │
└────────────────────────────────────────┘

✅ 추천: Elastic IP + Nginx
┌────────────────────────────────────────┐
│ EC2: $7.5/월                           │
│ EIP: $0 (사용 중)                      │
│ 합계: $7.5/월 ✅                       │
│                                        │
│ 단점:                                  │
│ • 배포 시 30초 다운타임 감수           │
│ • Let's Encrypt 수동 관리              │
│                                        │
│ 나중에 ALB 전환 계획:                  │
│ • 사용자 1,000명 이상 시               │
│ • 매출 발생 시                         │
└────────────────────────────────────────┘
```

### 시나리오 2: B2B SaaS (중규모)

```
요구사항:
• 기업 고객 (SLA 중요)
• 무중단 배포 필수
• 트래픽 변동 있음

✅ 추천: ALB + Auto Scaling
┌────────────────────────────────────────┐
│ ALB: $21/월                            │
│ EC2 (t3.small): 1~2대                  │
│ • 평소: $15/월                         │
│ • 부하시: $30/월                       │
│ RDS (db.t3.micro): $15/월              │
│ 합계: $51~66/월                        │
│                                        │
│ 가치:                                  │
│ • 99.9% SLA 보장 가능                  │
│ • 무중단 배포로 고객 신뢰              │
│ • Auto Scaling으로 비용 최적화         │
└────────────────────────────────────────┘
```

### 시나리오 3: 게임 서버 (특수)

```
요구사항:
• UDP 프로토콜
• 초저지연 (1ms 이하)
• 고정 IP 필요

✅ 추천: NLB + Elastic IP
┌────────────────────────────────────────┐
│ NLB: $16.2/월                          │
│ EIP (NLB 연결): $0                     │
│ EC2 (c5.large): $62/월                 │
│ 합계: $78/월                           │
│                                        │
│ 이유:                                  │
│ • NLB만 UDP 지원                       │
│ • NLB만 EIP 연결 가능                  │
│ • 마이크로초 단위 지연시간             │
└────────────────────────────────────────┘
```

### 시나리오 4: 마이크로서비스 (대규모)

```
요구사항:
• 여러 서비스 (API, Web, Admin)
• 독립 배포 필요
• 높은 가용성

✅ 추천: ALB + Path 라우팅
┌────────────────────────────────────────┐
│ ALB 1개: $21/월                        │
│ Target Groups:                         │
│  • /api → API 서버 (2대) $60/월        │
│  • /web → Web 서버 (2대) $60/월        │
│  • /admin → Admin (1대) $30/월         │
│ RDS: $50/월                            │
│ 합계: $221/월                          │
│                                        │
│ vs ALB 없이 (EIP 3개):                 │
│ • 같은 EC2 구성: $150/월               │
│ • RDS: $50/월                          │
│ • 합계: $200/월                        │
│                                        │
│ 🤔 비용은 비슷하지만...                │
│ ✅ ALB 장점:                           │
│ • Path 기반 라우팅 편리                │
│ • 무중단 배포                          │
│ • Health Check 자동화                  │
│ • Auto Scaling 지원                    │
│                                        │
│ → ALB 선택이 합리적 ✅                 │
└────────────────────────────────────────┘
```

---

## 핵심 정리

### 🎯 5가지 핵심 원칙

```
1️⃣ 로드밸런서 = 고정 엔드포인트 + 자동화
   • IGW는 단순히 인터넷 연결만
   • LB는 Health Check, 무중단 배포, SSL 등 제공

2️⃣ 서버 1대여도 ALB 가치 있음
   • 무중단 배포
   • 자동 장애 복구
   • SSL 관리 간소화
   • Auto Scaling 준비

3️⃣ ALB vs NLB 선택 기준
   • HTTP/HTTPS → ALB
   • TCP/UDP, 초고성능 → NLB
   • 고정 IP 필요 → NLB

4️⃣ Health Check는 필수
   • 서버 상태 자동 감지
   • 장애 서버 자동 제외
   • 복구 시 자동 포함

5️⃣ Connection Draining으로 안전한 배포
   • 기존 요청 완료 대기
   • 새 요청은 새 서버로
   • 다운타임 0초
```

### 🧠 이해도 자가 테스트

```
Q1: 서버 1대인데 ALB가 필요한 이유 3가지는?
A1: 1) 무중단 배포, 2) 자동 장애 복구, 3) SSL 관리 간소화

Q2: ALB와 NLB의 가장 큰 차이는?
A2: OSI 계층. ALB는 Layer 7 (HTTP 내용 확인), NLB는 Layer 4 (IP/Port만)

Q3: Health Check에서 Unhealthy로 판정되면?
A3: ALB가 해당 서버로 새 트래픽 전송 중단. 기존 연결은 Draining.

Q4: Connection Draining의 목적은?
A4: 서버 제거 시 기존 연결을 안전하게 완료시키기 위함 (다운타임 방지)

Q5: Path 기반 라우팅은 무엇인가?
A5: URL 경로에 따라 다른 서버로 전달. 예: /api → API 서버, /web → Web 서버
```

---

## 다음 단계

이제 로드밸런서를 완벽히 이해했으니:

1. **VPC Endpoint**: NAT 비용 없이 S3/DynamoDB 접근
2. **CloudFront + ALB**: CDN으로 전 세계 배포
3. **Route 53**: DNS 기반 라우팅과 장애 조치

다음 가이드에서 계속됩니다!

---

*마지막 업데이트: 2026-01-13*
